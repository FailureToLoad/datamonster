// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/failuretoload/datamonster/ent/predicate"
	"github.com/failuretoload/datamonster/ent/settlement"
	"github.com/failuretoload/datamonster/ent/survivor"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeSettlement = "Settlement"
	TypeSurvivor   = "Survivor"
)

// SettlementMutation represents an operation that mutates the Settlement nodes in the graph.
type SettlementMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	owner                  *string
	name                   *string
	survivalLimit          *int
	addsurvivalLimit       *int
	departingSurvival      *int
	adddepartingSurvival   *int
	collectiveCognition    *int
	addcollectiveCognition *int
	currentYear            *int
	addcurrentYear         *int
	clearedFields          map[string]struct{}
	population             map[int]struct{}
	removedpopulation      map[int]struct{}
	clearedpopulation      bool
	done                   bool
	oldValue               func(context.Context) (*Settlement, error)
	predicates             []predicate.Settlement
}

var _ ent.Mutation = (*SettlementMutation)(nil)

// settlementOption allows management of the mutation configuration using functional options.
type settlementOption func(*SettlementMutation)

// newSettlementMutation creates new mutation for the Settlement entity.
func newSettlementMutation(c config, op Op, opts ...settlementOption) *SettlementMutation {
	m := &SettlementMutation{
		config:        c,
		op:            op,
		typ:           TypeSettlement,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSettlementID sets the ID field of the mutation.
func withSettlementID(id int) settlementOption {
	return func(m *SettlementMutation) {
		var (
			err   error
			once  sync.Once
			value *Settlement
		)
		m.oldValue = func(ctx context.Context) (*Settlement, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Settlement.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSettlement sets the old Settlement of the mutation.
func withSettlement(node *Settlement) settlementOption {
	return func(m *SettlementMutation) {
		m.oldValue = func(context.Context) (*Settlement, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SettlementMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SettlementMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SettlementMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SettlementMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Settlement.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetOwner sets the "owner" field.
func (m *SettlementMutation) SetOwner(s string) {
	m.owner = &s
}

// Owner returns the value of the "owner" field in the mutation.
func (m *SettlementMutation) Owner() (r string, exists bool) {
	v := m.owner
	if v == nil {
		return
	}
	return *v, true
}

// OldOwner returns the old "owner" field's value of the Settlement entity.
// If the Settlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettlementMutation) OldOwner(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwner is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwner requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwner: %w", err)
	}
	return oldValue.Owner, nil
}

// ResetOwner resets all changes to the "owner" field.
func (m *SettlementMutation) ResetOwner() {
	m.owner = nil
}

// SetName sets the "name" field.
func (m *SettlementMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SettlementMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Settlement entity.
// If the Settlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettlementMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SettlementMutation) ResetName() {
	m.name = nil
}

// SetSurvivalLimit sets the "survivalLimit" field.
func (m *SettlementMutation) SetSurvivalLimit(i int) {
	m.survivalLimit = &i
	m.addsurvivalLimit = nil
}

// SurvivalLimit returns the value of the "survivalLimit" field in the mutation.
func (m *SettlementMutation) SurvivalLimit() (r int, exists bool) {
	v := m.survivalLimit
	if v == nil {
		return
	}
	return *v, true
}

// OldSurvivalLimit returns the old "survivalLimit" field's value of the Settlement entity.
// If the Settlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettlementMutation) OldSurvivalLimit(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSurvivalLimit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSurvivalLimit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSurvivalLimit: %w", err)
	}
	return oldValue.SurvivalLimit, nil
}

// AddSurvivalLimit adds i to the "survivalLimit" field.
func (m *SettlementMutation) AddSurvivalLimit(i int) {
	if m.addsurvivalLimit != nil {
		*m.addsurvivalLimit += i
	} else {
		m.addsurvivalLimit = &i
	}
}

// AddedSurvivalLimit returns the value that was added to the "survivalLimit" field in this mutation.
func (m *SettlementMutation) AddedSurvivalLimit() (r int, exists bool) {
	v := m.addsurvivalLimit
	if v == nil {
		return
	}
	return *v, true
}

// ResetSurvivalLimit resets all changes to the "survivalLimit" field.
func (m *SettlementMutation) ResetSurvivalLimit() {
	m.survivalLimit = nil
	m.addsurvivalLimit = nil
}

// SetDepartingSurvival sets the "departingSurvival" field.
func (m *SettlementMutation) SetDepartingSurvival(i int) {
	m.departingSurvival = &i
	m.adddepartingSurvival = nil
}

// DepartingSurvival returns the value of the "departingSurvival" field in the mutation.
func (m *SettlementMutation) DepartingSurvival() (r int, exists bool) {
	v := m.departingSurvival
	if v == nil {
		return
	}
	return *v, true
}

// OldDepartingSurvival returns the old "departingSurvival" field's value of the Settlement entity.
// If the Settlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettlementMutation) OldDepartingSurvival(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDepartingSurvival is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDepartingSurvival requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDepartingSurvival: %w", err)
	}
	return oldValue.DepartingSurvival, nil
}

// AddDepartingSurvival adds i to the "departingSurvival" field.
func (m *SettlementMutation) AddDepartingSurvival(i int) {
	if m.adddepartingSurvival != nil {
		*m.adddepartingSurvival += i
	} else {
		m.adddepartingSurvival = &i
	}
}

// AddedDepartingSurvival returns the value that was added to the "departingSurvival" field in this mutation.
func (m *SettlementMutation) AddedDepartingSurvival() (r int, exists bool) {
	v := m.adddepartingSurvival
	if v == nil {
		return
	}
	return *v, true
}

// ResetDepartingSurvival resets all changes to the "departingSurvival" field.
func (m *SettlementMutation) ResetDepartingSurvival() {
	m.departingSurvival = nil
	m.adddepartingSurvival = nil
}

// SetCollectiveCognition sets the "collectiveCognition" field.
func (m *SettlementMutation) SetCollectiveCognition(i int) {
	m.collectiveCognition = &i
	m.addcollectiveCognition = nil
}

// CollectiveCognition returns the value of the "collectiveCognition" field in the mutation.
func (m *SettlementMutation) CollectiveCognition() (r int, exists bool) {
	v := m.collectiveCognition
	if v == nil {
		return
	}
	return *v, true
}

// OldCollectiveCognition returns the old "collectiveCognition" field's value of the Settlement entity.
// If the Settlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettlementMutation) OldCollectiveCognition(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCollectiveCognition is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCollectiveCognition requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCollectiveCognition: %w", err)
	}
	return oldValue.CollectiveCognition, nil
}

// AddCollectiveCognition adds i to the "collectiveCognition" field.
func (m *SettlementMutation) AddCollectiveCognition(i int) {
	if m.addcollectiveCognition != nil {
		*m.addcollectiveCognition += i
	} else {
		m.addcollectiveCognition = &i
	}
}

// AddedCollectiveCognition returns the value that was added to the "collectiveCognition" field in this mutation.
func (m *SettlementMutation) AddedCollectiveCognition() (r int, exists bool) {
	v := m.addcollectiveCognition
	if v == nil {
		return
	}
	return *v, true
}

// ResetCollectiveCognition resets all changes to the "collectiveCognition" field.
func (m *SettlementMutation) ResetCollectiveCognition() {
	m.collectiveCognition = nil
	m.addcollectiveCognition = nil
}

// SetCurrentYear sets the "currentYear" field.
func (m *SettlementMutation) SetCurrentYear(i int) {
	m.currentYear = &i
	m.addcurrentYear = nil
}

// CurrentYear returns the value of the "currentYear" field in the mutation.
func (m *SettlementMutation) CurrentYear() (r int, exists bool) {
	v := m.currentYear
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrentYear returns the old "currentYear" field's value of the Settlement entity.
// If the Settlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettlementMutation) OldCurrentYear(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrentYear is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrentYear requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrentYear: %w", err)
	}
	return oldValue.CurrentYear, nil
}

// AddCurrentYear adds i to the "currentYear" field.
func (m *SettlementMutation) AddCurrentYear(i int) {
	if m.addcurrentYear != nil {
		*m.addcurrentYear += i
	} else {
		m.addcurrentYear = &i
	}
}

// AddedCurrentYear returns the value that was added to the "currentYear" field in this mutation.
func (m *SettlementMutation) AddedCurrentYear() (r int, exists bool) {
	v := m.addcurrentYear
	if v == nil {
		return
	}
	return *v, true
}

// ResetCurrentYear resets all changes to the "currentYear" field.
func (m *SettlementMutation) ResetCurrentYear() {
	m.currentYear = nil
	m.addcurrentYear = nil
}

// AddPopulationIDs adds the "population" edge to the Survivor entity by ids.
func (m *SettlementMutation) AddPopulationIDs(ids ...int) {
	if m.population == nil {
		m.population = make(map[int]struct{})
	}
	for i := range ids {
		m.population[ids[i]] = struct{}{}
	}
}

// ClearPopulation clears the "population" edge to the Survivor entity.
func (m *SettlementMutation) ClearPopulation() {
	m.clearedpopulation = true
}

// PopulationCleared reports if the "population" edge to the Survivor entity was cleared.
func (m *SettlementMutation) PopulationCleared() bool {
	return m.clearedpopulation
}

// RemovePopulationIDs removes the "population" edge to the Survivor entity by IDs.
func (m *SettlementMutation) RemovePopulationIDs(ids ...int) {
	if m.removedpopulation == nil {
		m.removedpopulation = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.population, ids[i])
		m.removedpopulation[ids[i]] = struct{}{}
	}
}

// RemovedPopulation returns the removed IDs of the "population" edge to the Survivor entity.
func (m *SettlementMutation) RemovedPopulationIDs() (ids []int) {
	for id := range m.removedpopulation {
		ids = append(ids, id)
	}
	return
}

// PopulationIDs returns the "population" edge IDs in the mutation.
func (m *SettlementMutation) PopulationIDs() (ids []int) {
	for id := range m.population {
		ids = append(ids, id)
	}
	return
}

// ResetPopulation resets all changes to the "population" edge.
func (m *SettlementMutation) ResetPopulation() {
	m.population = nil
	m.clearedpopulation = false
	m.removedpopulation = nil
}

// Where appends a list predicates to the SettlementMutation builder.
func (m *SettlementMutation) Where(ps ...predicate.Settlement) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SettlementMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SettlementMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Settlement, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SettlementMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SettlementMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Settlement).
func (m *SettlementMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SettlementMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.owner != nil {
		fields = append(fields, settlement.FieldOwner)
	}
	if m.name != nil {
		fields = append(fields, settlement.FieldName)
	}
	if m.survivalLimit != nil {
		fields = append(fields, settlement.FieldSurvivalLimit)
	}
	if m.departingSurvival != nil {
		fields = append(fields, settlement.FieldDepartingSurvival)
	}
	if m.collectiveCognition != nil {
		fields = append(fields, settlement.FieldCollectiveCognition)
	}
	if m.currentYear != nil {
		fields = append(fields, settlement.FieldCurrentYear)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SettlementMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case settlement.FieldOwner:
		return m.Owner()
	case settlement.FieldName:
		return m.Name()
	case settlement.FieldSurvivalLimit:
		return m.SurvivalLimit()
	case settlement.FieldDepartingSurvival:
		return m.DepartingSurvival()
	case settlement.FieldCollectiveCognition:
		return m.CollectiveCognition()
	case settlement.FieldCurrentYear:
		return m.CurrentYear()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SettlementMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case settlement.FieldOwner:
		return m.OldOwner(ctx)
	case settlement.FieldName:
		return m.OldName(ctx)
	case settlement.FieldSurvivalLimit:
		return m.OldSurvivalLimit(ctx)
	case settlement.FieldDepartingSurvival:
		return m.OldDepartingSurvival(ctx)
	case settlement.FieldCollectiveCognition:
		return m.OldCollectiveCognition(ctx)
	case settlement.FieldCurrentYear:
		return m.OldCurrentYear(ctx)
	}
	return nil, fmt.Errorf("unknown Settlement field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SettlementMutation) SetField(name string, value ent.Value) error {
	switch name {
	case settlement.FieldOwner:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwner(v)
		return nil
	case settlement.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case settlement.FieldSurvivalLimit:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSurvivalLimit(v)
		return nil
	case settlement.FieldDepartingSurvival:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDepartingSurvival(v)
		return nil
	case settlement.FieldCollectiveCognition:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCollectiveCognition(v)
		return nil
	case settlement.FieldCurrentYear:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrentYear(v)
		return nil
	}
	return fmt.Errorf("unknown Settlement field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SettlementMutation) AddedFields() []string {
	var fields []string
	if m.addsurvivalLimit != nil {
		fields = append(fields, settlement.FieldSurvivalLimit)
	}
	if m.adddepartingSurvival != nil {
		fields = append(fields, settlement.FieldDepartingSurvival)
	}
	if m.addcollectiveCognition != nil {
		fields = append(fields, settlement.FieldCollectiveCognition)
	}
	if m.addcurrentYear != nil {
		fields = append(fields, settlement.FieldCurrentYear)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SettlementMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case settlement.FieldSurvivalLimit:
		return m.AddedSurvivalLimit()
	case settlement.FieldDepartingSurvival:
		return m.AddedDepartingSurvival()
	case settlement.FieldCollectiveCognition:
		return m.AddedCollectiveCognition()
	case settlement.FieldCurrentYear:
		return m.AddedCurrentYear()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SettlementMutation) AddField(name string, value ent.Value) error {
	switch name {
	case settlement.FieldSurvivalLimit:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSurvivalLimit(v)
		return nil
	case settlement.FieldDepartingSurvival:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDepartingSurvival(v)
		return nil
	case settlement.FieldCollectiveCognition:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCollectiveCognition(v)
		return nil
	case settlement.FieldCurrentYear:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCurrentYear(v)
		return nil
	}
	return fmt.Errorf("unknown Settlement numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SettlementMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SettlementMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SettlementMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Settlement nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SettlementMutation) ResetField(name string) error {
	switch name {
	case settlement.FieldOwner:
		m.ResetOwner()
		return nil
	case settlement.FieldName:
		m.ResetName()
		return nil
	case settlement.FieldSurvivalLimit:
		m.ResetSurvivalLimit()
		return nil
	case settlement.FieldDepartingSurvival:
		m.ResetDepartingSurvival()
		return nil
	case settlement.FieldCollectiveCognition:
		m.ResetCollectiveCognition()
		return nil
	case settlement.FieldCurrentYear:
		m.ResetCurrentYear()
		return nil
	}
	return fmt.Errorf("unknown Settlement field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SettlementMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.population != nil {
		edges = append(edges, settlement.EdgePopulation)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SettlementMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case settlement.EdgePopulation:
		ids := make([]ent.Value, 0, len(m.population))
		for id := range m.population {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SettlementMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedpopulation != nil {
		edges = append(edges, settlement.EdgePopulation)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SettlementMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case settlement.EdgePopulation:
		ids := make([]ent.Value, 0, len(m.removedpopulation))
		for id := range m.removedpopulation {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SettlementMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedpopulation {
		edges = append(edges, settlement.EdgePopulation)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SettlementMutation) EdgeCleared(name string) bool {
	switch name {
	case settlement.EdgePopulation:
		return m.clearedpopulation
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SettlementMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Settlement unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SettlementMutation) ResetEdge(name string) error {
	switch name {
	case settlement.EdgePopulation:
		m.ResetPopulation()
		return nil
	}
	return fmt.Errorf("unknown Settlement edge %s", name)
}

// SurvivorMutation represents an operation that mutates the Survivor nodes in the graph.
type SurvivorMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	name                  *string
	born                  *int
	addborn               *int
	gender                *survivor.Gender
	huntxp                *int
	addhuntxp             *int
	survival              *int
	addsurvival           *int
	movement              *int
	addmovement           *int
	accuracy              *int
	addaccuracy           *int
	strength              *int
	addstrength           *int
	evasion               *int
	addevasion            *int
	luck                  *int
	addluck               *int
	speed                 *int
	addspeed              *int
	systemicpressure      *int
	addsystemicpressure   *int
	torment               *int
	addtorment            *int
	insanity              *int
	addinsanity           *int
	lumi                  *int
	addlumi               *int
	courage               *int
	addcourage            *int
	understanding         *int
	addunderstanding      *int
	status                *survivor.Status
	status_change_year    *int
	addstatus_change_year *int
	clearedFields         map[string]struct{}
	settlement            *int
	clearedsettlement     bool
	done                  bool
	oldValue              func(context.Context) (*Survivor, error)
	predicates            []predicate.Survivor
}

var _ ent.Mutation = (*SurvivorMutation)(nil)

// survivorOption allows management of the mutation configuration using functional options.
type survivorOption func(*SurvivorMutation)

// newSurvivorMutation creates new mutation for the Survivor entity.
func newSurvivorMutation(c config, op Op, opts ...survivorOption) *SurvivorMutation {
	m := &SurvivorMutation{
		config:        c,
		op:            op,
		typ:           TypeSurvivor,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSurvivorID sets the ID field of the mutation.
func withSurvivorID(id int) survivorOption {
	return func(m *SurvivorMutation) {
		var (
			err   error
			once  sync.Once
			value *Survivor
		)
		m.oldValue = func(ctx context.Context) (*Survivor, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Survivor.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSurvivor sets the old Survivor of the mutation.
func withSurvivor(node *Survivor) survivorOption {
	return func(m *SurvivorMutation) {
		m.oldValue = func(context.Context) (*Survivor, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SurvivorMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SurvivorMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SurvivorMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SurvivorMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Survivor.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *SurvivorMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SurvivorMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Survivor entity.
// If the Survivor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurvivorMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SurvivorMutation) ResetName() {
	m.name = nil
}

// SetBorn sets the "born" field.
func (m *SurvivorMutation) SetBorn(i int) {
	m.born = &i
	m.addborn = nil
}

// Born returns the value of the "born" field in the mutation.
func (m *SurvivorMutation) Born() (r int, exists bool) {
	v := m.born
	if v == nil {
		return
	}
	return *v, true
}

// OldBorn returns the old "born" field's value of the Survivor entity.
// If the Survivor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurvivorMutation) OldBorn(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBorn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBorn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBorn: %w", err)
	}
	return oldValue.Born, nil
}

// AddBorn adds i to the "born" field.
func (m *SurvivorMutation) AddBorn(i int) {
	if m.addborn != nil {
		*m.addborn += i
	} else {
		m.addborn = &i
	}
}

// AddedBorn returns the value that was added to the "born" field in this mutation.
func (m *SurvivorMutation) AddedBorn() (r int, exists bool) {
	v := m.addborn
	if v == nil {
		return
	}
	return *v, true
}

// ResetBorn resets all changes to the "born" field.
func (m *SurvivorMutation) ResetBorn() {
	m.born = nil
	m.addborn = nil
}

// SetGender sets the "gender" field.
func (m *SurvivorMutation) SetGender(s survivor.Gender) {
	m.gender = &s
}

// Gender returns the value of the "gender" field in the mutation.
func (m *SurvivorMutation) Gender() (r survivor.Gender, exists bool) {
	v := m.gender
	if v == nil {
		return
	}
	return *v, true
}

// OldGender returns the old "gender" field's value of the Survivor entity.
// If the Survivor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurvivorMutation) OldGender(ctx context.Context) (v survivor.Gender, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGender is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGender requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGender: %w", err)
	}
	return oldValue.Gender, nil
}

// ResetGender resets all changes to the "gender" field.
func (m *SurvivorMutation) ResetGender() {
	m.gender = nil
}

// SetHuntxp sets the "huntxp" field.
func (m *SurvivorMutation) SetHuntxp(i int) {
	m.huntxp = &i
	m.addhuntxp = nil
}

// Huntxp returns the value of the "huntxp" field in the mutation.
func (m *SurvivorMutation) Huntxp() (r int, exists bool) {
	v := m.huntxp
	if v == nil {
		return
	}
	return *v, true
}

// OldHuntxp returns the old "huntxp" field's value of the Survivor entity.
// If the Survivor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurvivorMutation) OldHuntxp(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHuntxp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHuntxp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHuntxp: %w", err)
	}
	return oldValue.Huntxp, nil
}

// AddHuntxp adds i to the "huntxp" field.
func (m *SurvivorMutation) AddHuntxp(i int) {
	if m.addhuntxp != nil {
		*m.addhuntxp += i
	} else {
		m.addhuntxp = &i
	}
}

// AddedHuntxp returns the value that was added to the "huntxp" field in this mutation.
func (m *SurvivorMutation) AddedHuntxp() (r int, exists bool) {
	v := m.addhuntxp
	if v == nil {
		return
	}
	return *v, true
}

// ResetHuntxp resets all changes to the "huntxp" field.
func (m *SurvivorMutation) ResetHuntxp() {
	m.huntxp = nil
	m.addhuntxp = nil
}

// SetSurvival sets the "survival" field.
func (m *SurvivorMutation) SetSurvival(i int) {
	m.survival = &i
	m.addsurvival = nil
}

// Survival returns the value of the "survival" field in the mutation.
func (m *SurvivorMutation) Survival() (r int, exists bool) {
	v := m.survival
	if v == nil {
		return
	}
	return *v, true
}

// OldSurvival returns the old "survival" field's value of the Survivor entity.
// If the Survivor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurvivorMutation) OldSurvival(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSurvival is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSurvival requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSurvival: %w", err)
	}
	return oldValue.Survival, nil
}

// AddSurvival adds i to the "survival" field.
func (m *SurvivorMutation) AddSurvival(i int) {
	if m.addsurvival != nil {
		*m.addsurvival += i
	} else {
		m.addsurvival = &i
	}
}

// AddedSurvival returns the value that was added to the "survival" field in this mutation.
func (m *SurvivorMutation) AddedSurvival() (r int, exists bool) {
	v := m.addsurvival
	if v == nil {
		return
	}
	return *v, true
}

// ResetSurvival resets all changes to the "survival" field.
func (m *SurvivorMutation) ResetSurvival() {
	m.survival = nil
	m.addsurvival = nil
}

// SetMovement sets the "movement" field.
func (m *SurvivorMutation) SetMovement(i int) {
	m.movement = &i
	m.addmovement = nil
}

// Movement returns the value of the "movement" field in the mutation.
func (m *SurvivorMutation) Movement() (r int, exists bool) {
	v := m.movement
	if v == nil {
		return
	}
	return *v, true
}

// OldMovement returns the old "movement" field's value of the Survivor entity.
// If the Survivor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurvivorMutation) OldMovement(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMovement is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMovement requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMovement: %w", err)
	}
	return oldValue.Movement, nil
}

// AddMovement adds i to the "movement" field.
func (m *SurvivorMutation) AddMovement(i int) {
	if m.addmovement != nil {
		*m.addmovement += i
	} else {
		m.addmovement = &i
	}
}

// AddedMovement returns the value that was added to the "movement" field in this mutation.
func (m *SurvivorMutation) AddedMovement() (r int, exists bool) {
	v := m.addmovement
	if v == nil {
		return
	}
	return *v, true
}

// ResetMovement resets all changes to the "movement" field.
func (m *SurvivorMutation) ResetMovement() {
	m.movement = nil
	m.addmovement = nil
}

// SetAccuracy sets the "accuracy" field.
func (m *SurvivorMutation) SetAccuracy(i int) {
	m.accuracy = &i
	m.addaccuracy = nil
}

// Accuracy returns the value of the "accuracy" field in the mutation.
func (m *SurvivorMutation) Accuracy() (r int, exists bool) {
	v := m.accuracy
	if v == nil {
		return
	}
	return *v, true
}

// OldAccuracy returns the old "accuracy" field's value of the Survivor entity.
// If the Survivor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurvivorMutation) OldAccuracy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccuracy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccuracy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccuracy: %w", err)
	}
	return oldValue.Accuracy, nil
}

// AddAccuracy adds i to the "accuracy" field.
func (m *SurvivorMutation) AddAccuracy(i int) {
	if m.addaccuracy != nil {
		*m.addaccuracy += i
	} else {
		m.addaccuracy = &i
	}
}

// AddedAccuracy returns the value that was added to the "accuracy" field in this mutation.
func (m *SurvivorMutation) AddedAccuracy() (r int, exists bool) {
	v := m.addaccuracy
	if v == nil {
		return
	}
	return *v, true
}

// ResetAccuracy resets all changes to the "accuracy" field.
func (m *SurvivorMutation) ResetAccuracy() {
	m.accuracy = nil
	m.addaccuracy = nil
}

// SetStrength sets the "strength" field.
func (m *SurvivorMutation) SetStrength(i int) {
	m.strength = &i
	m.addstrength = nil
}

// Strength returns the value of the "strength" field in the mutation.
func (m *SurvivorMutation) Strength() (r int, exists bool) {
	v := m.strength
	if v == nil {
		return
	}
	return *v, true
}

// OldStrength returns the old "strength" field's value of the Survivor entity.
// If the Survivor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurvivorMutation) OldStrength(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStrength is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStrength requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStrength: %w", err)
	}
	return oldValue.Strength, nil
}

// AddStrength adds i to the "strength" field.
func (m *SurvivorMutation) AddStrength(i int) {
	if m.addstrength != nil {
		*m.addstrength += i
	} else {
		m.addstrength = &i
	}
}

// AddedStrength returns the value that was added to the "strength" field in this mutation.
func (m *SurvivorMutation) AddedStrength() (r int, exists bool) {
	v := m.addstrength
	if v == nil {
		return
	}
	return *v, true
}

// ResetStrength resets all changes to the "strength" field.
func (m *SurvivorMutation) ResetStrength() {
	m.strength = nil
	m.addstrength = nil
}

// SetEvasion sets the "evasion" field.
func (m *SurvivorMutation) SetEvasion(i int) {
	m.evasion = &i
	m.addevasion = nil
}

// Evasion returns the value of the "evasion" field in the mutation.
func (m *SurvivorMutation) Evasion() (r int, exists bool) {
	v := m.evasion
	if v == nil {
		return
	}
	return *v, true
}

// OldEvasion returns the old "evasion" field's value of the Survivor entity.
// If the Survivor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurvivorMutation) OldEvasion(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEvasion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEvasion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEvasion: %w", err)
	}
	return oldValue.Evasion, nil
}

// AddEvasion adds i to the "evasion" field.
func (m *SurvivorMutation) AddEvasion(i int) {
	if m.addevasion != nil {
		*m.addevasion += i
	} else {
		m.addevasion = &i
	}
}

// AddedEvasion returns the value that was added to the "evasion" field in this mutation.
func (m *SurvivorMutation) AddedEvasion() (r int, exists bool) {
	v := m.addevasion
	if v == nil {
		return
	}
	return *v, true
}

// ResetEvasion resets all changes to the "evasion" field.
func (m *SurvivorMutation) ResetEvasion() {
	m.evasion = nil
	m.addevasion = nil
}

// SetLuck sets the "luck" field.
func (m *SurvivorMutation) SetLuck(i int) {
	m.luck = &i
	m.addluck = nil
}

// Luck returns the value of the "luck" field in the mutation.
func (m *SurvivorMutation) Luck() (r int, exists bool) {
	v := m.luck
	if v == nil {
		return
	}
	return *v, true
}

// OldLuck returns the old "luck" field's value of the Survivor entity.
// If the Survivor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurvivorMutation) OldLuck(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLuck is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLuck requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLuck: %w", err)
	}
	return oldValue.Luck, nil
}

// AddLuck adds i to the "luck" field.
func (m *SurvivorMutation) AddLuck(i int) {
	if m.addluck != nil {
		*m.addluck += i
	} else {
		m.addluck = &i
	}
}

// AddedLuck returns the value that was added to the "luck" field in this mutation.
func (m *SurvivorMutation) AddedLuck() (r int, exists bool) {
	v := m.addluck
	if v == nil {
		return
	}
	return *v, true
}

// ResetLuck resets all changes to the "luck" field.
func (m *SurvivorMutation) ResetLuck() {
	m.luck = nil
	m.addluck = nil
}

// SetSpeed sets the "speed" field.
func (m *SurvivorMutation) SetSpeed(i int) {
	m.speed = &i
	m.addspeed = nil
}

// Speed returns the value of the "speed" field in the mutation.
func (m *SurvivorMutation) Speed() (r int, exists bool) {
	v := m.speed
	if v == nil {
		return
	}
	return *v, true
}

// OldSpeed returns the old "speed" field's value of the Survivor entity.
// If the Survivor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurvivorMutation) OldSpeed(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSpeed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSpeed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpeed: %w", err)
	}
	return oldValue.Speed, nil
}

// AddSpeed adds i to the "speed" field.
func (m *SurvivorMutation) AddSpeed(i int) {
	if m.addspeed != nil {
		*m.addspeed += i
	} else {
		m.addspeed = &i
	}
}

// AddedSpeed returns the value that was added to the "speed" field in this mutation.
func (m *SurvivorMutation) AddedSpeed() (r int, exists bool) {
	v := m.addspeed
	if v == nil {
		return
	}
	return *v, true
}

// ResetSpeed resets all changes to the "speed" field.
func (m *SurvivorMutation) ResetSpeed() {
	m.speed = nil
	m.addspeed = nil
}

// SetSystemicpressure sets the "systemicpressure" field.
func (m *SurvivorMutation) SetSystemicpressure(i int) {
	m.systemicpressure = &i
	m.addsystemicpressure = nil
}

// Systemicpressure returns the value of the "systemicpressure" field in the mutation.
func (m *SurvivorMutation) Systemicpressure() (r int, exists bool) {
	v := m.systemicpressure
	if v == nil {
		return
	}
	return *v, true
}

// OldSystemicpressure returns the old "systemicpressure" field's value of the Survivor entity.
// If the Survivor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurvivorMutation) OldSystemicpressure(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSystemicpressure is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSystemicpressure requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSystemicpressure: %w", err)
	}
	return oldValue.Systemicpressure, nil
}

// AddSystemicpressure adds i to the "systemicpressure" field.
func (m *SurvivorMutation) AddSystemicpressure(i int) {
	if m.addsystemicpressure != nil {
		*m.addsystemicpressure += i
	} else {
		m.addsystemicpressure = &i
	}
}

// AddedSystemicpressure returns the value that was added to the "systemicpressure" field in this mutation.
func (m *SurvivorMutation) AddedSystemicpressure() (r int, exists bool) {
	v := m.addsystemicpressure
	if v == nil {
		return
	}
	return *v, true
}

// ResetSystemicpressure resets all changes to the "systemicpressure" field.
func (m *SurvivorMutation) ResetSystemicpressure() {
	m.systemicpressure = nil
	m.addsystemicpressure = nil
}

// SetTorment sets the "torment" field.
func (m *SurvivorMutation) SetTorment(i int) {
	m.torment = &i
	m.addtorment = nil
}

// Torment returns the value of the "torment" field in the mutation.
func (m *SurvivorMutation) Torment() (r int, exists bool) {
	v := m.torment
	if v == nil {
		return
	}
	return *v, true
}

// OldTorment returns the old "torment" field's value of the Survivor entity.
// If the Survivor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurvivorMutation) OldTorment(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTorment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTorment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTorment: %w", err)
	}
	return oldValue.Torment, nil
}

// AddTorment adds i to the "torment" field.
func (m *SurvivorMutation) AddTorment(i int) {
	if m.addtorment != nil {
		*m.addtorment += i
	} else {
		m.addtorment = &i
	}
}

// AddedTorment returns the value that was added to the "torment" field in this mutation.
func (m *SurvivorMutation) AddedTorment() (r int, exists bool) {
	v := m.addtorment
	if v == nil {
		return
	}
	return *v, true
}

// ResetTorment resets all changes to the "torment" field.
func (m *SurvivorMutation) ResetTorment() {
	m.torment = nil
	m.addtorment = nil
}

// SetInsanity sets the "insanity" field.
func (m *SurvivorMutation) SetInsanity(i int) {
	m.insanity = &i
	m.addinsanity = nil
}

// Insanity returns the value of the "insanity" field in the mutation.
func (m *SurvivorMutation) Insanity() (r int, exists bool) {
	v := m.insanity
	if v == nil {
		return
	}
	return *v, true
}

// OldInsanity returns the old "insanity" field's value of the Survivor entity.
// If the Survivor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurvivorMutation) OldInsanity(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInsanity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInsanity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInsanity: %w", err)
	}
	return oldValue.Insanity, nil
}

// AddInsanity adds i to the "insanity" field.
func (m *SurvivorMutation) AddInsanity(i int) {
	if m.addinsanity != nil {
		*m.addinsanity += i
	} else {
		m.addinsanity = &i
	}
}

// AddedInsanity returns the value that was added to the "insanity" field in this mutation.
func (m *SurvivorMutation) AddedInsanity() (r int, exists bool) {
	v := m.addinsanity
	if v == nil {
		return
	}
	return *v, true
}

// ResetInsanity resets all changes to the "insanity" field.
func (m *SurvivorMutation) ResetInsanity() {
	m.insanity = nil
	m.addinsanity = nil
}

// SetLumi sets the "lumi" field.
func (m *SurvivorMutation) SetLumi(i int) {
	m.lumi = &i
	m.addlumi = nil
}

// Lumi returns the value of the "lumi" field in the mutation.
func (m *SurvivorMutation) Lumi() (r int, exists bool) {
	v := m.lumi
	if v == nil {
		return
	}
	return *v, true
}

// OldLumi returns the old "lumi" field's value of the Survivor entity.
// If the Survivor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurvivorMutation) OldLumi(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLumi is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLumi requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLumi: %w", err)
	}
	return oldValue.Lumi, nil
}

// AddLumi adds i to the "lumi" field.
func (m *SurvivorMutation) AddLumi(i int) {
	if m.addlumi != nil {
		*m.addlumi += i
	} else {
		m.addlumi = &i
	}
}

// AddedLumi returns the value that was added to the "lumi" field in this mutation.
func (m *SurvivorMutation) AddedLumi() (r int, exists bool) {
	v := m.addlumi
	if v == nil {
		return
	}
	return *v, true
}

// ResetLumi resets all changes to the "lumi" field.
func (m *SurvivorMutation) ResetLumi() {
	m.lumi = nil
	m.addlumi = nil
}

// SetCourage sets the "courage" field.
func (m *SurvivorMutation) SetCourage(i int) {
	m.courage = &i
	m.addcourage = nil
}

// Courage returns the value of the "courage" field in the mutation.
func (m *SurvivorMutation) Courage() (r int, exists bool) {
	v := m.courage
	if v == nil {
		return
	}
	return *v, true
}

// OldCourage returns the old "courage" field's value of the Survivor entity.
// If the Survivor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurvivorMutation) OldCourage(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCourage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCourage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCourage: %w", err)
	}
	return oldValue.Courage, nil
}

// AddCourage adds i to the "courage" field.
func (m *SurvivorMutation) AddCourage(i int) {
	if m.addcourage != nil {
		*m.addcourage += i
	} else {
		m.addcourage = &i
	}
}

// AddedCourage returns the value that was added to the "courage" field in this mutation.
func (m *SurvivorMutation) AddedCourage() (r int, exists bool) {
	v := m.addcourage
	if v == nil {
		return
	}
	return *v, true
}

// ResetCourage resets all changes to the "courage" field.
func (m *SurvivorMutation) ResetCourage() {
	m.courage = nil
	m.addcourage = nil
}

// SetUnderstanding sets the "understanding" field.
func (m *SurvivorMutation) SetUnderstanding(i int) {
	m.understanding = &i
	m.addunderstanding = nil
}

// Understanding returns the value of the "understanding" field in the mutation.
func (m *SurvivorMutation) Understanding() (r int, exists bool) {
	v := m.understanding
	if v == nil {
		return
	}
	return *v, true
}

// OldUnderstanding returns the old "understanding" field's value of the Survivor entity.
// If the Survivor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurvivorMutation) OldUnderstanding(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnderstanding is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnderstanding requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnderstanding: %w", err)
	}
	return oldValue.Understanding, nil
}

// AddUnderstanding adds i to the "understanding" field.
func (m *SurvivorMutation) AddUnderstanding(i int) {
	if m.addunderstanding != nil {
		*m.addunderstanding += i
	} else {
		m.addunderstanding = &i
	}
}

// AddedUnderstanding returns the value that was added to the "understanding" field in this mutation.
func (m *SurvivorMutation) AddedUnderstanding() (r int, exists bool) {
	v := m.addunderstanding
	if v == nil {
		return
	}
	return *v, true
}

// ResetUnderstanding resets all changes to the "understanding" field.
func (m *SurvivorMutation) ResetUnderstanding() {
	m.understanding = nil
	m.addunderstanding = nil
}

// SetStatus sets the "status" field.
func (m *SurvivorMutation) SetStatus(s survivor.Status) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *SurvivorMutation) Status() (r survivor.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Survivor entity.
// If the Survivor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurvivorMutation) OldStatus(ctx context.Context) (v survivor.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *SurvivorMutation) ResetStatus() {
	m.status = nil
}

// SetStatusChangeYear sets the "status_change_year" field.
func (m *SurvivorMutation) SetStatusChangeYear(i int) {
	m.status_change_year = &i
	m.addstatus_change_year = nil
}

// StatusChangeYear returns the value of the "status_change_year" field in the mutation.
func (m *SurvivorMutation) StatusChangeYear() (r int, exists bool) {
	v := m.status_change_year
	if v == nil {
		return
	}
	return *v, true
}

// OldStatusChangeYear returns the old "status_change_year" field's value of the Survivor entity.
// If the Survivor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurvivorMutation) OldStatusChangeYear(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatusChangeYear is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatusChangeYear requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatusChangeYear: %w", err)
	}
	return oldValue.StatusChangeYear, nil
}

// AddStatusChangeYear adds i to the "status_change_year" field.
func (m *SurvivorMutation) AddStatusChangeYear(i int) {
	if m.addstatus_change_year != nil {
		*m.addstatus_change_year += i
	} else {
		m.addstatus_change_year = &i
	}
}

// AddedStatusChangeYear returns the value that was added to the "status_change_year" field in this mutation.
func (m *SurvivorMutation) AddedStatusChangeYear() (r int, exists bool) {
	v := m.addstatus_change_year
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatusChangeYear resets all changes to the "status_change_year" field.
func (m *SurvivorMutation) ResetStatusChangeYear() {
	m.status_change_year = nil
	m.addstatus_change_year = nil
}

// SetSettlementID sets the "settlement_id" field.
func (m *SurvivorMutation) SetSettlementID(i int) {
	m.settlement = &i
}

// SettlementID returns the value of the "settlement_id" field in the mutation.
func (m *SurvivorMutation) SettlementID() (r int, exists bool) {
	v := m.settlement
	if v == nil {
		return
	}
	return *v, true
}

// OldSettlementID returns the old "settlement_id" field's value of the Survivor entity.
// If the Survivor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurvivorMutation) OldSettlementID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSettlementID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSettlementID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSettlementID: %w", err)
	}
	return oldValue.SettlementID, nil
}

// ClearSettlementID clears the value of the "settlement_id" field.
func (m *SurvivorMutation) ClearSettlementID() {
	m.settlement = nil
	m.clearedFields[survivor.FieldSettlementID] = struct{}{}
}

// SettlementIDCleared returns if the "settlement_id" field was cleared in this mutation.
func (m *SurvivorMutation) SettlementIDCleared() bool {
	_, ok := m.clearedFields[survivor.FieldSettlementID]
	return ok
}

// ResetSettlementID resets all changes to the "settlement_id" field.
func (m *SurvivorMutation) ResetSettlementID() {
	m.settlement = nil
	delete(m.clearedFields, survivor.FieldSettlementID)
}

// ClearSettlement clears the "settlement" edge to the Settlement entity.
func (m *SurvivorMutation) ClearSettlement() {
	m.clearedsettlement = true
	m.clearedFields[survivor.FieldSettlementID] = struct{}{}
}

// SettlementCleared reports if the "settlement" edge to the Settlement entity was cleared.
func (m *SurvivorMutation) SettlementCleared() bool {
	return m.SettlementIDCleared() || m.clearedsettlement
}

// SettlementIDs returns the "settlement" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SettlementID instead. It exists only for internal usage by the builders.
func (m *SurvivorMutation) SettlementIDs() (ids []int) {
	if id := m.settlement; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSettlement resets all changes to the "settlement" edge.
func (m *SurvivorMutation) ResetSettlement() {
	m.settlement = nil
	m.clearedsettlement = false
}

// Where appends a list predicates to the SurvivorMutation builder.
func (m *SurvivorMutation) Where(ps ...predicate.Survivor) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SurvivorMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SurvivorMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Survivor, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SurvivorMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SurvivorMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Survivor).
func (m *SurvivorMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SurvivorMutation) Fields() []string {
	fields := make([]string, 0, 20)
	if m.name != nil {
		fields = append(fields, survivor.FieldName)
	}
	if m.born != nil {
		fields = append(fields, survivor.FieldBorn)
	}
	if m.gender != nil {
		fields = append(fields, survivor.FieldGender)
	}
	if m.huntxp != nil {
		fields = append(fields, survivor.FieldHuntxp)
	}
	if m.survival != nil {
		fields = append(fields, survivor.FieldSurvival)
	}
	if m.movement != nil {
		fields = append(fields, survivor.FieldMovement)
	}
	if m.accuracy != nil {
		fields = append(fields, survivor.FieldAccuracy)
	}
	if m.strength != nil {
		fields = append(fields, survivor.FieldStrength)
	}
	if m.evasion != nil {
		fields = append(fields, survivor.FieldEvasion)
	}
	if m.luck != nil {
		fields = append(fields, survivor.FieldLuck)
	}
	if m.speed != nil {
		fields = append(fields, survivor.FieldSpeed)
	}
	if m.systemicpressure != nil {
		fields = append(fields, survivor.FieldSystemicpressure)
	}
	if m.torment != nil {
		fields = append(fields, survivor.FieldTorment)
	}
	if m.insanity != nil {
		fields = append(fields, survivor.FieldInsanity)
	}
	if m.lumi != nil {
		fields = append(fields, survivor.FieldLumi)
	}
	if m.courage != nil {
		fields = append(fields, survivor.FieldCourage)
	}
	if m.understanding != nil {
		fields = append(fields, survivor.FieldUnderstanding)
	}
	if m.status != nil {
		fields = append(fields, survivor.FieldStatus)
	}
	if m.status_change_year != nil {
		fields = append(fields, survivor.FieldStatusChangeYear)
	}
	if m.settlement != nil {
		fields = append(fields, survivor.FieldSettlementID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SurvivorMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case survivor.FieldName:
		return m.Name()
	case survivor.FieldBorn:
		return m.Born()
	case survivor.FieldGender:
		return m.Gender()
	case survivor.FieldHuntxp:
		return m.Huntxp()
	case survivor.FieldSurvival:
		return m.Survival()
	case survivor.FieldMovement:
		return m.Movement()
	case survivor.FieldAccuracy:
		return m.Accuracy()
	case survivor.FieldStrength:
		return m.Strength()
	case survivor.FieldEvasion:
		return m.Evasion()
	case survivor.FieldLuck:
		return m.Luck()
	case survivor.FieldSpeed:
		return m.Speed()
	case survivor.FieldSystemicpressure:
		return m.Systemicpressure()
	case survivor.FieldTorment:
		return m.Torment()
	case survivor.FieldInsanity:
		return m.Insanity()
	case survivor.FieldLumi:
		return m.Lumi()
	case survivor.FieldCourage:
		return m.Courage()
	case survivor.FieldUnderstanding:
		return m.Understanding()
	case survivor.FieldStatus:
		return m.Status()
	case survivor.FieldStatusChangeYear:
		return m.StatusChangeYear()
	case survivor.FieldSettlementID:
		return m.SettlementID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SurvivorMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case survivor.FieldName:
		return m.OldName(ctx)
	case survivor.FieldBorn:
		return m.OldBorn(ctx)
	case survivor.FieldGender:
		return m.OldGender(ctx)
	case survivor.FieldHuntxp:
		return m.OldHuntxp(ctx)
	case survivor.FieldSurvival:
		return m.OldSurvival(ctx)
	case survivor.FieldMovement:
		return m.OldMovement(ctx)
	case survivor.FieldAccuracy:
		return m.OldAccuracy(ctx)
	case survivor.FieldStrength:
		return m.OldStrength(ctx)
	case survivor.FieldEvasion:
		return m.OldEvasion(ctx)
	case survivor.FieldLuck:
		return m.OldLuck(ctx)
	case survivor.FieldSpeed:
		return m.OldSpeed(ctx)
	case survivor.FieldSystemicpressure:
		return m.OldSystemicpressure(ctx)
	case survivor.FieldTorment:
		return m.OldTorment(ctx)
	case survivor.FieldInsanity:
		return m.OldInsanity(ctx)
	case survivor.FieldLumi:
		return m.OldLumi(ctx)
	case survivor.FieldCourage:
		return m.OldCourage(ctx)
	case survivor.FieldUnderstanding:
		return m.OldUnderstanding(ctx)
	case survivor.FieldStatus:
		return m.OldStatus(ctx)
	case survivor.FieldStatusChangeYear:
		return m.OldStatusChangeYear(ctx)
	case survivor.FieldSettlementID:
		return m.OldSettlementID(ctx)
	}
	return nil, fmt.Errorf("unknown Survivor field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SurvivorMutation) SetField(name string, value ent.Value) error {
	switch name {
	case survivor.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case survivor.FieldBorn:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBorn(v)
		return nil
	case survivor.FieldGender:
		v, ok := value.(survivor.Gender)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGender(v)
		return nil
	case survivor.FieldHuntxp:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHuntxp(v)
		return nil
	case survivor.FieldSurvival:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSurvival(v)
		return nil
	case survivor.FieldMovement:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMovement(v)
		return nil
	case survivor.FieldAccuracy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccuracy(v)
		return nil
	case survivor.FieldStrength:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStrength(v)
		return nil
	case survivor.FieldEvasion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEvasion(v)
		return nil
	case survivor.FieldLuck:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLuck(v)
		return nil
	case survivor.FieldSpeed:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpeed(v)
		return nil
	case survivor.FieldSystemicpressure:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSystemicpressure(v)
		return nil
	case survivor.FieldTorment:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTorment(v)
		return nil
	case survivor.FieldInsanity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInsanity(v)
		return nil
	case survivor.FieldLumi:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLumi(v)
		return nil
	case survivor.FieldCourage:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCourage(v)
		return nil
	case survivor.FieldUnderstanding:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnderstanding(v)
		return nil
	case survivor.FieldStatus:
		v, ok := value.(survivor.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case survivor.FieldStatusChangeYear:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatusChangeYear(v)
		return nil
	case survivor.FieldSettlementID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSettlementID(v)
		return nil
	}
	return fmt.Errorf("unknown Survivor field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SurvivorMutation) AddedFields() []string {
	var fields []string
	if m.addborn != nil {
		fields = append(fields, survivor.FieldBorn)
	}
	if m.addhuntxp != nil {
		fields = append(fields, survivor.FieldHuntxp)
	}
	if m.addsurvival != nil {
		fields = append(fields, survivor.FieldSurvival)
	}
	if m.addmovement != nil {
		fields = append(fields, survivor.FieldMovement)
	}
	if m.addaccuracy != nil {
		fields = append(fields, survivor.FieldAccuracy)
	}
	if m.addstrength != nil {
		fields = append(fields, survivor.FieldStrength)
	}
	if m.addevasion != nil {
		fields = append(fields, survivor.FieldEvasion)
	}
	if m.addluck != nil {
		fields = append(fields, survivor.FieldLuck)
	}
	if m.addspeed != nil {
		fields = append(fields, survivor.FieldSpeed)
	}
	if m.addsystemicpressure != nil {
		fields = append(fields, survivor.FieldSystemicpressure)
	}
	if m.addtorment != nil {
		fields = append(fields, survivor.FieldTorment)
	}
	if m.addinsanity != nil {
		fields = append(fields, survivor.FieldInsanity)
	}
	if m.addlumi != nil {
		fields = append(fields, survivor.FieldLumi)
	}
	if m.addcourage != nil {
		fields = append(fields, survivor.FieldCourage)
	}
	if m.addunderstanding != nil {
		fields = append(fields, survivor.FieldUnderstanding)
	}
	if m.addstatus_change_year != nil {
		fields = append(fields, survivor.FieldStatusChangeYear)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SurvivorMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case survivor.FieldBorn:
		return m.AddedBorn()
	case survivor.FieldHuntxp:
		return m.AddedHuntxp()
	case survivor.FieldSurvival:
		return m.AddedSurvival()
	case survivor.FieldMovement:
		return m.AddedMovement()
	case survivor.FieldAccuracy:
		return m.AddedAccuracy()
	case survivor.FieldStrength:
		return m.AddedStrength()
	case survivor.FieldEvasion:
		return m.AddedEvasion()
	case survivor.FieldLuck:
		return m.AddedLuck()
	case survivor.FieldSpeed:
		return m.AddedSpeed()
	case survivor.FieldSystemicpressure:
		return m.AddedSystemicpressure()
	case survivor.FieldTorment:
		return m.AddedTorment()
	case survivor.FieldInsanity:
		return m.AddedInsanity()
	case survivor.FieldLumi:
		return m.AddedLumi()
	case survivor.FieldCourage:
		return m.AddedCourage()
	case survivor.FieldUnderstanding:
		return m.AddedUnderstanding()
	case survivor.FieldStatusChangeYear:
		return m.AddedStatusChangeYear()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SurvivorMutation) AddField(name string, value ent.Value) error {
	switch name {
	case survivor.FieldBorn:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBorn(v)
		return nil
	case survivor.FieldHuntxp:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHuntxp(v)
		return nil
	case survivor.FieldSurvival:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSurvival(v)
		return nil
	case survivor.FieldMovement:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMovement(v)
		return nil
	case survivor.FieldAccuracy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAccuracy(v)
		return nil
	case survivor.FieldStrength:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStrength(v)
		return nil
	case survivor.FieldEvasion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEvasion(v)
		return nil
	case survivor.FieldLuck:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLuck(v)
		return nil
	case survivor.FieldSpeed:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSpeed(v)
		return nil
	case survivor.FieldSystemicpressure:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSystemicpressure(v)
		return nil
	case survivor.FieldTorment:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTorment(v)
		return nil
	case survivor.FieldInsanity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddInsanity(v)
		return nil
	case survivor.FieldLumi:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLumi(v)
		return nil
	case survivor.FieldCourage:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCourage(v)
		return nil
	case survivor.FieldUnderstanding:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUnderstanding(v)
		return nil
	case survivor.FieldStatusChangeYear:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatusChangeYear(v)
		return nil
	}
	return fmt.Errorf("unknown Survivor numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SurvivorMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(survivor.FieldSettlementID) {
		fields = append(fields, survivor.FieldSettlementID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SurvivorMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SurvivorMutation) ClearField(name string) error {
	switch name {
	case survivor.FieldSettlementID:
		m.ClearSettlementID()
		return nil
	}
	return fmt.Errorf("unknown Survivor nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SurvivorMutation) ResetField(name string) error {
	switch name {
	case survivor.FieldName:
		m.ResetName()
		return nil
	case survivor.FieldBorn:
		m.ResetBorn()
		return nil
	case survivor.FieldGender:
		m.ResetGender()
		return nil
	case survivor.FieldHuntxp:
		m.ResetHuntxp()
		return nil
	case survivor.FieldSurvival:
		m.ResetSurvival()
		return nil
	case survivor.FieldMovement:
		m.ResetMovement()
		return nil
	case survivor.FieldAccuracy:
		m.ResetAccuracy()
		return nil
	case survivor.FieldStrength:
		m.ResetStrength()
		return nil
	case survivor.FieldEvasion:
		m.ResetEvasion()
		return nil
	case survivor.FieldLuck:
		m.ResetLuck()
		return nil
	case survivor.FieldSpeed:
		m.ResetSpeed()
		return nil
	case survivor.FieldSystemicpressure:
		m.ResetSystemicpressure()
		return nil
	case survivor.FieldTorment:
		m.ResetTorment()
		return nil
	case survivor.FieldInsanity:
		m.ResetInsanity()
		return nil
	case survivor.FieldLumi:
		m.ResetLumi()
		return nil
	case survivor.FieldCourage:
		m.ResetCourage()
		return nil
	case survivor.FieldUnderstanding:
		m.ResetUnderstanding()
		return nil
	case survivor.FieldStatus:
		m.ResetStatus()
		return nil
	case survivor.FieldStatusChangeYear:
		m.ResetStatusChangeYear()
		return nil
	case survivor.FieldSettlementID:
		m.ResetSettlementID()
		return nil
	}
	return fmt.Errorf("unknown Survivor field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SurvivorMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.settlement != nil {
		edges = append(edges, survivor.EdgeSettlement)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SurvivorMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case survivor.EdgeSettlement:
		if id := m.settlement; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SurvivorMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SurvivorMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SurvivorMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedsettlement {
		edges = append(edges, survivor.EdgeSettlement)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SurvivorMutation) EdgeCleared(name string) bool {
	switch name {
	case survivor.EdgeSettlement:
		return m.clearedsettlement
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SurvivorMutation) ClearEdge(name string) error {
	switch name {
	case survivor.EdgeSettlement:
		m.ClearSettlement()
		return nil
	}
	return fmt.Errorf("unknown Survivor unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SurvivorMutation) ResetEdge(name string) error {
	switch name {
	case survivor.EdgeSettlement:
		m.ResetSettlement()
		return nil
	}
	return fmt.Errorf("unknown Survivor edge %s", name)
}
