// Code generated by ent, DO NOT EDIT.

package ent

import (
	"errors"
	"fmt"

	"github.com/failuretoload/datamonster/ent/predicate"
	"github.com/failuretoload/datamonster/ent/settlement"
	"github.com/failuretoload/datamonster/ent/survivor"
)

// SettlementWhereInput represents a where input for filtering Settlement queries.
type SettlementWhereInput struct {
	Predicates []predicate.Settlement  `json:"-"`
	Not        *SettlementWhereInput   `json:"not,omitempty"`
	Or         []*SettlementWhereInput `json:"or,omitempty"`
	And        []*SettlementWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "owner" field predicates.
	Owner             *string  `json:"owner,omitempty"`
	OwnerNEQ          *string  `json:"ownerNEQ,omitempty"`
	OwnerIn           []string `json:"ownerIn,omitempty"`
	OwnerNotIn        []string `json:"ownerNotIn,omitempty"`
	OwnerGT           *string  `json:"ownerGT,omitempty"`
	OwnerGTE          *string  `json:"ownerGTE,omitempty"`
	OwnerLT           *string  `json:"ownerLT,omitempty"`
	OwnerLTE          *string  `json:"ownerLTE,omitempty"`
	OwnerContains     *string  `json:"ownerContains,omitempty"`
	OwnerHasPrefix    *string  `json:"ownerHasPrefix,omitempty"`
	OwnerHasSuffix    *string  `json:"ownerHasSuffix,omitempty"`
	OwnerEqualFold    *string  `json:"ownerEqualFold,omitempty"`
	OwnerContainsFold *string  `json:"ownerContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "survivalLimit" field predicates.
	SurvivalLimit      *int  `json:"survivallimit,omitempty"`
	SurvivalLimitNEQ   *int  `json:"survivallimitNEQ,omitempty"`
	SurvivalLimitIn    []int `json:"survivallimitIn,omitempty"`
	SurvivalLimitNotIn []int `json:"survivallimitNotIn,omitempty"`
	SurvivalLimitGT    *int  `json:"survivallimitGT,omitempty"`
	SurvivalLimitGTE   *int  `json:"survivallimitGTE,omitempty"`
	SurvivalLimitLT    *int  `json:"survivallimitLT,omitempty"`
	SurvivalLimitLTE   *int  `json:"survivallimitLTE,omitempty"`

	// "departingSurvival" field predicates.
	DepartingSurvival      *int  `json:"departingsurvival,omitempty"`
	DepartingSurvivalNEQ   *int  `json:"departingsurvivalNEQ,omitempty"`
	DepartingSurvivalIn    []int `json:"departingsurvivalIn,omitempty"`
	DepartingSurvivalNotIn []int `json:"departingsurvivalNotIn,omitempty"`
	DepartingSurvivalGT    *int  `json:"departingsurvivalGT,omitempty"`
	DepartingSurvivalGTE   *int  `json:"departingsurvivalGTE,omitempty"`
	DepartingSurvivalLT    *int  `json:"departingsurvivalLT,omitempty"`
	DepartingSurvivalLTE   *int  `json:"departingsurvivalLTE,omitempty"`

	// "collectiveCognition" field predicates.
	CollectiveCognition      *int  `json:"collectivecognition,omitempty"`
	CollectiveCognitionNEQ   *int  `json:"collectivecognitionNEQ,omitempty"`
	CollectiveCognitionIn    []int `json:"collectivecognitionIn,omitempty"`
	CollectiveCognitionNotIn []int `json:"collectivecognitionNotIn,omitempty"`
	CollectiveCognitionGT    *int  `json:"collectivecognitionGT,omitempty"`
	CollectiveCognitionGTE   *int  `json:"collectivecognitionGTE,omitempty"`
	CollectiveCognitionLT    *int  `json:"collectivecognitionLT,omitempty"`
	CollectiveCognitionLTE   *int  `json:"collectivecognitionLTE,omitempty"`

	// "currentYear" field predicates.
	CurrentYear      *int  `json:"currentyear,omitempty"`
	CurrentYearNEQ   *int  `json:"currentyearNEQ,omitempty"`
	CurrentYearIn    []int `json:"currentyearIn,omitempty"`
	CurrentYearNotIn []int `json:"currentyearNotIn,omitempty"`
	CurrentYearGT    *int  `json:"currentyearGT,omitempty"`
	CurrentYearGTE   *int  `json:"currentyearGTE,omitempty"`
	CurrentYearLT    *int  `json:"currentyearLT,omitempty"`
	CurrentYearLTE   *int  `json:"currentyearLTE,omitempty"`

	// "population" edge predicates.
	HasPopulation     *bool                 `json:"hasPopulation,omitempty"`
	HasPopulationWith []*SurvivorWhereInput `json:"hasPopulationWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *SettlementWhereInput) AddPredicates(predicates ...predicate.Settlement) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the SettlementWhereInput filter on the SettlementQuery builder.
func (i *SettlementWhereInput) Filter(q *SettlementQuery) (*SettlementQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptySettlementWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptySettlementWhereInput is returned in case the SettlementWhereInput is empty.
var ErrEmptySettlementWhereInput = errors.New("ent: empty predicate SettlementWhereInput")

// P returns a predicate for filtering settlements.
// An error is returned if the input is empty or invalid.
func (i *SettlementWhereInput) P() (predicate.Settlement, error) {
	var predicates []predicate.Settlement
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, settlement.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Settlement, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, settlement.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Settlement, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, settlement.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, settlement.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, settlement.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, settlement.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, settlement.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, settlement.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, settlement.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, settlement.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, settlement.IDLTE(*i.IDLTE))
	}
	if i.Owner != nil {
		predicates = append(predicates, settlement.OwnerEQ(*i.Owner))
	}
	if i.OwnerNEQ != nil {
		predicates = append(predicates, settlement.OwnerNEQ(*i.OwnerNEQ))
	}
	if len(i.OwnerIn) > 0 {
		predicates = append(predicates, settlement.OwnerIn(i.OwnerIn...))
	}
	if len(i.OwnerNotIn) > 0 {
		predicates = append(predicates, settlement.OwnerNotIn(i.OwnerNotIn...))
	}
	if i.OwnerGT != nil {
		predicates = append(predicates, settlement.OwnerGT(*i.OwnerGT))
	}
	if i.OwnerGTE != nil {
		predicates = append(predicates, settlement.OwnerGTE(*i.OwnerGTE))
	}
	if i.OwnerLT != nil {
		predicates = append(predicates, settlement.OwnerLT(*i.OwnerLT))
	}
	if i.OwnerLTE != nil {
		predicates = append(predicates, settlement.OwnerLTE(*i.OwnerLTE))
	}
	if i.OwnerContains != nil {
		predicates = append(predicates, settlement.OwnerContains(*i.OwnerContains))
	}
	if i.OwnerHasPrefix != nil {
		predicates = append(predicates, settlement.OwnerHasPrefix(*i.OwnerHasPrefix))
	}
	if i.OwnerHasSuffix != nil {
		predicates = append(predicates, settlement.OwnerHasSuffix(*i.OwnerHasSuffix))
	}
	if i.OwnerEqualFold != nil {
		predicates = append(predicates, settlement.OwnerEqualFold(*i.OwnerEqualFold))
	}
	if i.OwnerContainsFold != nil {
		predicates = append(predicates, settlement.OwnerContainsFold(*i.OwnerContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, settlement.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, settlement.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, settlement.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, settlement.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, settlement.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, settlement.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, settlement.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, settlement.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, settlement.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, settlement.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, settlement.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, settlement.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, settlement.NameContainsFold(*i.NameContainsFold))
	}
	if i.SurvivalLimit != nil {
		predicates = append(predicates, settlement.SurvivalLimitEQ(*i.SurvivalLimit))
	}
	if i.SurvivalLimitNEQ != nil {
		predicates = append(predicates, settlement.SurvivalLimitNEQ(*i.SurvivalLimitNEQ))
	}
	if len(i.SurvivalLimitIn) > 0 {
		predicates = append(predicates, settlement.SurvivalLimitIn(i.SurvivalLimitIn...))
	}
	if len(i.SurvivalLimitNotIn) > 0 {
		predicates = append(predicates, settlement.SurvivalLimitNotIn(i.SurvivalLimitNotIn...))
	}
	if i.SurvivalLimitGT != nil {
		predicates = append(predicates, settlement.SurvivalLimitGT(*i.SurvivalLimitGT))
	}
	if i.SurvivalLimitGTE != nil {
		predicates = append(predicates, settlement.SurvivalLimitGTE(*i.SurvivalLimitGTE))
	}
	if i.SurvivalLimitLT != nil {
		predicates = append(predicates, settlement.SurvivalLimitLT(*i.SurvivalLimitLT))
	}
	if i.SurvivalLimitLTE != nil {
		predicates = append(predicates, settlement.SurvivalLimitLTE(*i.SurvivalLimitLTE))
	}
	if i.DepartingSurvival != nil {
		predicates = append(predicates, settlement.DepartingSurvivalEQ(*i.DepartingSurvival))
	}
	if i.DepartingSurvivalNEQ != nil {
		predicates = append(predicates, settlement.DepartingSurvivalNEQ(*i.DepartingSurvivalNEQ))
	}
	if len(i.DepartingSurvivalIn) > 0 {
		predicates = append(predicates, settlement.DepartingSurvivalIn(i.DepartingSurvivalIn...))
	}
	if len(i.DepartingSurvivalNotIn) > 0 {
		predicates = append(predicates, settlement.DepartingSurvivalNotIn(i.DepartingSurvivalNotIn...))
	}
	if i.DepartingSurvivalGT != nil {
		predicates = append(predicates, settlement.DepartingSurvivalGT(*i.DepartingSurvivalGT))
	}
	if i.DepartingSurvivalGTE != nil {
		predicates = append(predicates, settlement.DepartingSurvivalGTE(*i.DepartingSurvivalGTE))
	}
	if i.DepartingSurvivalLT != nil {
		predicates = append(predicates, settlement.DepartingSurvivalLT(*i.DepartingSurvivalLT))
	}
	if i.DepartingSurvivalLTE != nil {
		predicates = append(predicates, settlement.DepartingSurvivalLTE(*i.DepartingSurvivalLTE))
	}
	if i.CollectiveCognition != nil {
		predicates = append(predicates, settlement.CollectiveCognitionEQ(*i.CollectiveCognition))
	}
	if i.CollectiveCognitionNEQ != nil {
		predicates = append(predicates, settlement.CollectiveCognitionNEQ(*i.CollectiveCognitionNEQ))
	}
	if len(i.CollectiveCognitionIn) > 0 {
		predicates = append(predicates, settlement.CollectiveCognitionIn(i.CollectiveCognitionIn...))
	}
	if len(i.CollectiveCognitionNotIn) > 0 {
		predicates = append(predicates, settlement.CollectiveCognitionNotIn(i.CollectiveCognitionNotIn...))
	}
	if i.CollectiveCognitionGT != nil {
		predicates = append(predicates, settlement.CollectiveCognitionGT(*i.CollectiveCognitionGT))
	}
	if i.CollectiveCognitionGTE != nil {
		predicates = append(predicates, settlement.CollectiveCognitionGTE(*i.CollectiveCognitionGTE))
	}
	if i.CollectiveCognitionLT != nil {
		predicates = append(predicates, settlement.CollectiveCognitionLT(*i.CollectiveCognitionLT))
	}
	if i.CollectiveCognitionLTE != nil {
		predicates = append(predicates, settlement.CollectiveCognitionLTE(*i.CollectiveCognitionLTE))
	}
	if i.CurrentYear != nil {
		predicates = append(predicates, settlement.CurrentYearEQ(*i.CurrentYear))
	}
	if i.CurrentYearNEQ != nil {
		predicates = append(predicates, settlement.CurrentYearNEQ(*i.CurrentYearNEQ))
	}
	if len(i.CurrentYearIn) > 0 {
		predicates = append(predicates, settlement.CurrentYearIn(i.CurrentYearIn...))
	}
	if len(i.CurrentYearNotIn) > 0 {
		predicates = append(predicates, settlement.CurrentYearNotIn(i.CurrentYearNotIn...))
	}
	if i.CurrentYearGT != nil {
		predicates = append(predicates, settlement.CurrentYearGT(*i.CurrentYearGT))
	}
	if i.CurrentYearGTE != nil {
		predicates = append(predicates, settlement.CurrentYearGTE(*i.CurrentYearGTE))
	}
	if i.CurrentYearLT != nil {
		predicates = append(predicates, settlement.CurrentYearLT(*i.CurrentYearLT))
	}
	if i.CurrentYearLTE != nil {
		predicates = append(predicates, settlement.CurrentYearLTE(*i.CurrentYearLTE))
	}

	if i.HasPopulation != nil {
		p := settlement.HasPopulation()
		if !*i.HasPopulation {
			p = settlement.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPopulationWith) > 0 {
		with := make([]predicate.Survivor, 0, len(i.HasPopulationWith))
		for _, w := range i.HasPopulationWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPopulationWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, settlement.HasPopulationWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptySettlementWhereInput
	case 1:
		return predicates[0], nil
	default:
		return settlement.And(predicates...), nil
	}
}

// SurvivorWhereInput represents a where input for filtering Survivor queries.
type SurvivorWhereInput struct {
	Predicates []predicate.Survivor  `json:"-"`
	Not        *SurvivorWhereInput   `json:"not,omitempty"`
	Or         []*SurvivorWhereInput `json:"or,omitempty"`
	And        []*SurvivorWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "born" field predicates.
	Born      *int  `json:"born,omitempty"`
	BornNEQ   *int  `json:"bornNEQ,omitempty"`
	BornIn    []int `json:"bornIn,omitempty"`
	BornNotIn []int `json:"bornNotIn,omitempty"`
	BornGT    *int  `json:"bornGT,omitempty"`
	BornGTE   *int  `json:"bornGTE,omitempty"`
	BornLT    *int  `json:"bornLT,omitempty"`
	BornLTE   *int  `json:"bornLTE,omitempty"`

	// "gender" field predicates.
	Gender      *survivor.Gender  `json:"gender,omitempty"`
	GenderNEQ   *survivor.Gender  `json:"genderNEQ,omitempty"`
	GenderIn    []survivor.Gender `json:"genderIn,omitempty"`
	GenderNotIn []survivor.Gender `json:"genderNotIn,omitempty"`

	// "huntxp" field predicates.
	Huntxp      *int  `json:"huntxp,omitempty"`
	HuntxpNEQ   *int  `json:"huntxpNEQ,omitempty"`
	HuntxpIn    []int `json:"huntxpIn,omitempty"`
	HuntxpNotIn []int `json:"huntxpNotIn,omitempty"`
	HuntxpGT    *int  `json:"huntxpGT,omitempty"`
	HuntxpGTE   *int  `json:"huntxpGTE,omitempty"`
	HuntxpLT    *int  `json:"huntxpLT,omitempty"`
	HuntxpLTE   *int  `json:"huntxpLTE,omitempty"`

	// "survival" field predicates.
	Survival      *int  `json:"survival,omitempty"`
	SurvivalNEQ   *int  `json:"survivalNEQ,omitempty"`
	SurvivalIn    []int `json:"survivalIn,omitempty"`
	SurvivalNotIn []int `json:"survivalNotIn,omitempty"`
	SurvivalGT    *int  `json:"survivalGT,omitempty"`
	SurvivalGTE   *int  `json:"survivalGTE,omitempty"`
	SurvivalLT    *int  `json:"survivalLT,omitempty"`
	SurvivalLTE   *int  `json:"survivalLTE,omitempty"`

	// "movement" field predicates.
	Movement      *int  `json:"movement,omitempty"`
	MovementNEQ   *int  `json:"movementNEQ,omitempty"`
	MovementIn    []int `json:"movementIn,omitempty"`
	MovementNotIn []int `json:"movementNotIn,omitempty"`
	MovementGT    *int  `json:"movementGT,omitempty"`
	MovementGTE   *int  `json:"movementGTE,omitempty"`
	MovementLT    *int  `json:"movementLT,omitempty"`
	MovementLTE   *int  `json:"movementLTE,omitempty"`

	// "accuracy" field predicates.
	Accuracy      *int  `json:"accuracy,omitempty"`
	AccuracyNEQ   *int  `json:"accuracyNEQ,omitempty"`
	AccuracyIn    []int `json:"accuracyIn,omitempty"`
	AccuracyNotIn []int `json:"accuracyNotIn,omitempty"`
	AccuracyGT    *int  `json:"accuracyGT,omitempty"`
	AccuracyGTE   *int  `json:"accuracyGTE,omitempty"`
	AccuracyLT    *int  `json:"accuracyLT,omitempty"`
	AccuracyLTE   *int  `json:"accuracyLTE,omitempty"`

	// "strength" field predicates.
	Strength      *int  `json:"strength,omitempty"`
	StrengthNEQ   *int  `json:"strengthNEQ,omitempty"`
	StrengthIn    []int `json:"strengthIn,omitempty"`
	StrengthNotIn []int `json:"strengthNotIn,omitempty"`
	StrengthGT    *int  `json:"strengthGT,omitempty"`
	StrengthGTE   *int  `json:"strengthGTE,omitempty"`
	StrengthLT    *int  `json:"strengthLT,omitempty"`
	StrengthLTE   *int  `json:"strengthLTE,omitempty"`

	// "evasion" field predicates.
	Evasion      *int  `json:"evasion,omitempty"`
	EvasionNEQ   *int  `json:"evasionNEQ,omitempty"`
	EvasionIn    []int `json:"evasionIn,omitempty"`
	EvasionNotIn []int `json:"evasionNotIn,omitempty"`
	EvasionGT    *int  `json:"evasionGT,omitempty"`
	EvasionGTE   *int  `json:"evasionGTE,omitempty"`
	EvasionLT    *int  `json:"evasionLT,omitempty"`
	EvasionLTE   *int  `json:"evasionLTE,omitempty"`

	// "luck" field predicates.
	Luck      *int  `json:"luck,omitempty"`
	LuckNEQ   *int  `json:"luckNEQ,omitempty"`
	LuckIn    []int `json:"luckIn,omitempty"`
	LuckNotIn []int `json:"luckNotIn,omitempty"`
	LuckGT    *int  `json:"luckGT,omitempty"`
	LuckGTE   *int  `json:"luckGTE,omitempty"`
	LuckLT    *int  `json:"luckLT,omitempty"`
	LuckLTE   *int  `json:"luckLTE,omitempty"`

	// "speed" field predicates.
	Speed      *int  `json:"speed,omitempty"`
	SpeedNEQ   *int  `json:"speedNEQ,omitempty"`
	SpeedIn    []int `json:"speedIn,omitempty"`
	SpeedNotIn []int `json:"speedNotIn,omitempty"`
	SpeedGT    *int  `json:"speedGT,omitempty"`
	SpeedGTE   *int  `json:"speedGTE,omitempty"`
	SpeedLT    *int  `json:"speedLT,omitempty"`
	SpeedLTE   *int  `json:"speedLTE,omitempty"`

	// "systemicpressure" field predicates.
	Systemicpressure      *int  `json:"systemicpressure,omitempty"`
	SystemicpressureNEQ   *int  `json:"systemicpressureNEQ,omitempty"`
	SystemicpressureIn    []int `json:"systemicpressureIn,omitempty"`
	SystemicpressureNotIn []int `json:"systemicpressureNotIn,omitempty"`
	SystemicpressureGT    *int  `json:"systemicpressureGT,omitempty"`
	SystemicpressureGTE   *int  `json:"systemicpressureGTE,omitempty"`
	SystemicpressureLT    *int  `json:"systemicpressureLT,omitempty"`
	SystemicpressureLTE   *int  `json:"systemicpressureLTE,omitempty"`

	// "torment" field predicates.
	Torment      *int  `json:"torment,omitempty"`
	TormentNEQ   *int  `json:"tormentNEQ,omitempty"`
	TormentIn    []int `json:"tormentIn,omitempty"`
	TormentNotIn []int `json:"tormentNotIn,omitempty"`
	TormentGT    *int  `json:"tormentGT,omitempty"`
	TormentGTE   *int  `json:"tormentGTE,omitempty"`
	TormentLT    *int  `json:"tormentLT,omitempty"`
	TormentLTE   *int  `json:"tormentLTE,omitempty"`

	// "insanity" field predicates.
	Insanity      *int  `json:"insanity,omitempty"`
	InsanityNEQ   *int  `json:"insanityNEQ,omitempty"`
	InsanityIn    []int `json:"insanityIn,omitempty"`
	InsanityNotIn []int `json:"insanityNotIn,omitempty"`
	InsanityGT    *int  `json:"insanityGT,omitempty"`
	InsanityGTE   *int  `json:"insanityGTE,omitempty"`
	InsanityLT    *int  `json:"insanityLT,omitempty"`
	InsanityLTE   *int  `json:"insanityLTE,omitempty"`

	// "lumi" field predicates.
	Lumi      *int  `json:"lumi,omitempty"`
	LumiNEQ   *int  `json:"lumiNEQ,omitempty"`
	LumiIn    []int `json:"lumiIn,omitempty"`
	LumiNotIn []int `json:"lumiNotIn,omitempty"`
	LumiGT    *int  `json:"lumiGT,omitempty"`
	LumiGTE   *int  `json:"lumiGTE,omitempty"`
	LumiLT    *int  `json:"lumiLT,omitempty"`
	LumiLTE   *int  `json:"lumiLTE,omitempty"`

	// "courage" field predicates.
	Courage      *int  `json:"courage,omitempty"`
	CourageNEQ   *int  `json:"courageNEQ,omitempty"`
	CourageIn    []int `json:"courageIn,omitempty"`
	CourageNotIn []int `json:"courageNotIn,omitempty"`
	CourageGT    *int  `json:"courageGT,omitempty"`
	CourageGTE   *int  `json:"courageGTE,omitempty"`
	CourageLT    *int  `json:"courageLT,omitempty"`
	CourageLTE   *int  `json:"courageLTE,omitempty"`

	// "understanding" field predicates.
	Understanding      *int  `json:"understanding,omitempty"`
	UnderstandingNEQ   *int  `json:"understandingNEQ,omitempty"`
	UnderstandingIn    []int `json:"understandingIn,omitempty"`
	UnderstandingNotIn []int `json:"understandingNotIn,omitempty"`
	UnderstandingGT    *int  `json:"understandingGT,omitempty"`
	UnderstandingGTE   *int  `json:"understandingGTE,omitempty"`
	UnderstandingLT    *int  `json:"understandingLT,omitempty"`
	UnderstandingLTE   *int  `json:"understandingLTE,omitempty"`

	// "settlement_id" field predicates.
	SettlementID       *int  `json:"settlementID,omitempty"`
	SettlementIDNEQ    *int  `json:"settlementIDNEQ,omitempty"`
	SettlementIDIn     []int `json:"settlementIDIn,omitempty"`
	SettlementIDNotIn  []int `json:"settlementIDNotIn,omitempty"`
	SettlementIDIsNil  bool  `json:"settlementIDIsNil,omitempty"`
	SettlementIDNotNil bool  `json:"settlementIDNotNil,omitempty"`

	// "settlement" edge predicates.
	HasSettlement     *bool                   `json:"hasSettlement,omitempty"`
	HasSettlementWith []*SettlementWhereInput `json:"hasSettlementWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *SurvivorWhereInput) AddPredicates(predicates ...predicate.Survivor) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the SurvivorWhereInput filter on the SurvivorQuery builder.
func (i *SurvivorWhereInput) Filter(q *SurvivorQuery) (*SurvivorQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptySurvivorWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptySurvivorWhereInput is returned in case the SurvivorWhereInput is empty.
var ErrEmptySurvivorWhereInput = errors.New("ent: empty predicate SurvivorWhereInput")

// P returns a predicate for filtering survivors.
// An error is returned if the input is empty or invalid.
func (i *SurvivorWhereInput) P() (predicate.Survivor, error) {
	var predicates []predicate.Survivor
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, survivor.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Survivor, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, survivor.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Survivor, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, survivor.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, survivor.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, survivor.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, survivor.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, survivor.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, survivor.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, survivor.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, survivor.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, survivor.IDLTE(*i.IDLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, survivor.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, survivor.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, survivor.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, survivor.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, survivor.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, survivor.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, survivor.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, survivor.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, survivor.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, survivor.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, survivor.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, survivor.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, survivor.NameContainsFold(*i.NameContainsFold))
	}
	if i.Born != nil {
		predicates = append(predicates, survivor.BornEQ(*i.Born))
	}
	if i.BornNEQ != nil {
		predicates = append(predicates, survivor.BornNEQ(*i.BornNEQ))
	}
	if len(i.BornIn) > 0 {
		predicates = append(predicates, survivor.BornIn(i.BornIn...))
	}
	if len(i.BornNotIn) > 0 {
		predicates = append(predicates, survivor.BornNotIn(i.BornNotIn...))
	}
	if i.BornGT != nil {
		predicates = append(predicates, survivor.BornGT(*i.BornGT))
	}
	if i.BornGTE != nil {
		predicates = append(predicates, survivor.BornGTE(*i.BornGTE))
	}
	if i.BornLT != nil {
		predicates = append(predicates, survivor.BornLT(*i.BornLT))
	}
	if i.BornLTE != nil {
		predicates = append(predicates, survivor.BornLTE(*i.BornLTE))
	}
	if i.Gender != nil {
		predicates = append(predicates, survivor.GenderEQ(*i.Gender))
	}
	if i.GenderNEQ != nil {
		predicates = append(predicates, survivor.GenderNEQ(*i.GenderNEQ))
	}
	if len(i.GenderIn) > 0 {
		predicates = append(predicates, survivor.GenderIn(i.GenderIn...))
	}
	if len(i.GenderNotIn) > 0 {
		predicates = append(predicates, survivor.GenderNotIn(i.GenderNotIn...))
	}
	if i.Huntxp != nil {
		predicates = append(predicates, survivor.HuntxpEQ(*i.Huntxp))
	}
	if i.HuntxpNEQ != nil {
		predicates = append(predicates, survivor.HuntxpNEQ(*i.HuntxpNEQ))
	}
	if len(i.HuntxpIn) > 0 {
		predicates = append(predicates, survivor.HuntxpIn(i.HuntxpIn...))
	}
	if len(i.HuntxpNotIn) > 0 {
		predicates = append(predicates, survivor.HuntxpNotIn(i.HuntxpNotIn...))
	}
	if i.HuntxpGT != nil {
		predicates = append(predicates, survivor.HuntxpGT(*i.HuntxpGT))
	}
	if i.HuntxpGTE != nil {
		predicates = append(predicates, survivor.HuntxpGTE(*i.HuntxpGTE))
	}
	if i.HuntxpLT != nil {
		predicates = append(predicates, survivor.HuntxpLT(*i.HuntxpLT))
	}
	if i.HuntxpLTE != nil {
		predicates = append(predicates, survivor.HuntxpLTE(*i.HuntxpLTE))
	}
	if i.Survival != nil {
		predicates = append(predicates, survivor.SurvivalEQ(*i.Survival))
	}
	if i.SurvivalNEQ != nil {
		predicates = append(predicates, survivor.SurvivalNEQ(*i.SurvivalNEQ))
	}
	if len(i.SurvivalIn) > 0 {
		predicates = append(predicates, survivor.SurvivalIn(i.SurvivalIn...))
	}
	if len(i.SurvivalNotIn) > 0 {
		predicates = append(predicates, survivor.SurvivalNotIn(i.SurvivalNotIn...))
	}
	if i.SurvivalGT != nil {
		predicates = append(predicates, survivor.SurvivalGT(*i.SurvivalGT))
	}
	if i.SurvivalGTE != nil {
		predicates = append(predicates, survivor.SurvivalGTE(*i.SurvivalGTE))
	}
	if i.SurvivalLT != nil {
		predicates = append(predicates, survivor.SurvivalLT(*i.SurvivalLT))
	}
	if i.SurvivalLTE != nil {
		predicates = append(predicates, survivor.SurvivalLTE(*i.SurvivalLTE))
	}
	if i.Movement != nil {
		predicates = append(predicates, survivor.MovementEQ(*i.Movement))
	}
	if i.MovementNEQ != nil {
		predicates = append(predicates, survivor.MovementNEQ(*i.MovementNEQ))
	}
	if len(i.MovementIn) > 0 {
		predicates = append(predicates, survivor.MovementIn(i.MovementIn...))
	}
	if len(i.MovementNotIn) > 0 {
		predicates = append(predicates, survivor.MovementNotIn(i.MovementNotIn...))
	}
	if i.MovementGT != nil {
		predicates = append(predicates, survivor.MovementGT(*i.MovementGT))
	}
	if i.MovementGTE != nil {
		predicates = append(predicates, survivor.MovementGTE(*i.MovementGTE))
	}
	if i.MovementLT != nil {
		predicates = append(predicates, survivor.MovementLT(*i.MovementLT))
	}
	if i.MovementLTE != nil {
		predicates = append(predicates, survivor.MovementLTE(*i.MovementLTE))
	}
	if i.Accuracy != nil {
		predicates = append(predicates, survivor.AccuracyEQ(*i.Accuracy))
	}
	if i.AccuracyNEQ != nil {
		predicates = append(predicates, survivor.AccuracyNEQ(*i.AccuracyNEQ))
	}
	if len(i.AccuracyIn) > 0 {
		predicates = append(predicates, survivor.AccuracyIn(i.AccuracyIn...))
	}
	if len(i.AccuracyNotIn) > 0 {
		predicates = append(predicates, survivor.AccuracyNotIn(i.AccuracyNotIn...))
	}
	if i.AccuracyGT != nil {
		predicates = append(predicates, survivor.AccuracyGT(*i.AccuracyGT))
	}
	if i.AccuracyGTE != nil {
		predicates = append(predicates, survivor.AccuracyGTE(*i.AccuracyGTE))
	}
	if i.AccuracyLT != nil {
		predicates = append(predicates, survivor.AccuracyLT(*i.AccuracyLT))
	}
	if i.AccuracyLTE != nil {
		predicates = append(predicates, survivor.AccuracyLTE(*i.AccuracyLTE))
	}
	if i.Strength != nil {
		predicates = append(predicates, survivor.StrengthEQ(*i.Strength))
	}
	if i.StrengthNEQ != nil {
		predicates = append(predicates, survivor.StrengthNEQ(*i.StrengthNEQ))
	}
	if len(i.StrengthIn) > 0 {
		predicates = append(predicates, survivor.StrengthIn(i.StrengthIn...))
	}
	if len(i.StrengthNotIn) > 0 {
		predicates = append(predicates, survivor.StrengthNotIn(i.StrengthNotIn...))
	}
	if i.StrengthGT != nil {
		predicates = append(predicates, survivor.StrengthGT(*i.StrengthGT))
	}
	if i.StrengthGTE != nil {
		predicates = append(predicates, survivor.StrengthGTE(*i.StrengthGTE))
	}
	if i.StrengthLT != nil {
		predicates = append(predicates, survivor.StrengthLT(*i.StrengthLT))
	}
	if i.StrengthLTE != nil {
		predicates = append(predicates, survivor.StrengthLTE(*i.StrengthLTE))
	}
	if i.Evasion != nil {
		predicates = append(predicates, survivor.EvasionEQ(*i.Evasion))
	}
	if i.EvasionNEQ != nil {
		predicates = append(predicates, survivor.EvasionNEQ(*i.EvasionNEQ))
	}
	if len(i.EvasionIn) > 0 {
		predicates = append(predicates, survivor.EvasionIn(i.EvasionIn...))
	}
	if len(i.EvasionNotIn) > 0 {
		predicates = append(predicates, survivor.EvasionNotIn(i.EvasionNotIn...))
	}
	if i.EvasionGT != nil {
		predicates = append(predicates, survivor.EvasionGT(*i.EvasionGT))
	}
	if i.EvasionGTE != nil {
		predicates = append(predicates, survivor.EvasionGTE(*i.EvasionGTE))
	}
	if i.EvasionLT != nil {
		predicates = append(predicates, survivor.EvasionLT(*i.EvasionLT))
	}
	if i.EvasionLTE != nil {
		predicates = append(predicates, survivor.EvasionLTE(*i.EvasionLTE))
	}
	if i.Luck != nil {
		predicates = append(predicates, survivor.LuckEQ(*i.Luck))
	}
	if i.LuckNEQ != nil {
		predicates = append(predicates, survivor.LuckNEQ(*i.LuckNEQ))
	}
	if len(i.LuckIn) > 0 {
		predicates = append(predicates, survivor.LuckIn(i.LuckIn...))
	}
	if len(i.LuckNotIn) > 0 {
		predicates = append(predicates, survivor.LuckNotIn(i.LuckNotIn...))
	}
	if i.LuckGT != nil {
		predicates = append(predicates, survivor.LuckGT(*i.LuckGT))
	}
	if i.LuckGTE != nil {
		predicates = append(predicates, survivor.LuckGTE(*i.LuckGTE))
	}
	if i.LuckLT != nil {
		predicates = append(predicates, survivor.LuckLT(*i.LuckLT))
	}
	if i.LuckLTE != nil {
		predicates = append(predicates, survivor.LuckLTE(*i.LuckLTE))
	}
	if i.Speed != nil {
		predicates = append(predicates, survivor.SpeedEQ(*i.Speed))
	}
	if i.SpeedNEQ != nil {
		predicates = append(predicates, survivor.SpeedNEQ(*i.SpeedNEQ))
	}
	if len(i.SpeedIn) > 0 {
		predicates = append(predicates, survivor.SpeedIn(i.SpeedIn...))
	}
	if len(i.SpeedNotIn) > 0 {
		predicates = append(predicates, survivor.SpeedNotIn(i.SpeedNotIn...))
	}
	if i.SpeedGT != nil {
		predicates = append(predicates, survivor.SpeedGT(*i.SpeedGT))
	}
	if i.SpeedGTE != nil {
		predicates = append(predicates, survivor.SpeedGTE(*i.SpeedGTE))
	}
	if i.SpeedLT != nil {
		predicates = append(predicates, survivor.SpeedLT(*i.SpeedLT))
	}
	if i.SpeedLTE != nil {
		predicates = append(predicates, survivor.SpeedLTE(*i.SpeedLTE))
	}
	if i.Systemicpressure != nil {
		predicates = append(predicates, survivor.SystemicpressureEQ(*i.Systemicpressure))
	}
	if i.SystemicpressureNEQ != nil {
		predicates = append(predicates, survivor.SystemicpressureNEQ(*i.SystemicpressureNEQ))
	}
	if len(i.SystemicpressureIn) > 0 {
		predicates = append(predicates, survivor.SystemicpressureIn(i.SystemicpressureIn...))
	}
	if len(i.SystemicpressureNotIn) > 0 {
		predicates = append(predicates, survivor.SystemicpressureNotIn(i.SystemicpressureNotIn...))
	}
	if i.SystemicpressureGT != nil {
		predicates = append(predicates, survivor.SystemicpressureGT(*i.SystemicpressureGT))
	}
	if i.SystemicpressureGTE != nil {
		predicates = append(predicates, survivor.SystemicpressureGTE(*i.SystemicpressureGTE))
	}
	if i.SystemicpressureLT != nil {
		predicates = append(predicates, survivor.SystemicpressureLT(*i.SystemicpressureLT))
	}
	if i.SystemicpressureLTE != nil {
		predicates = append(predicates, survivor.SystemicpressureLTE(*i.SystemicpressureLTE))
	}
	if i.Torment != nil {
		predicates = append(predicates, survivor.TormentEQ(*i.Torment))
	}
	if i.TormentNEQ != nil {
		predicates = append(predicates, survivor.TormentNEQ(*i.TormentNEQ))
	}
	if len(i.TormentIn) > 0 {
		predicates = append(predicates, survivor.TormentIn(i.TormentIn...))
	}
	if len(i.TormentNotIn) > 0 {
		predicates = append(predicates, survivor.TormentNotIn(i.TormentNotIn...))
	}
	if i.TormentGT != nil {
		predicates = append(predicates, survivor.TormentGT(*i.TormentGT))
	}
	if i.TormentGTE != nil {
		predicates = append(predicates, survivor.TormentGTE(*i.TormentGTE))
	}
	if i.TormentLT != nil {
		predicates = append(predicates, survivor.TormentLT(*i.TormentLT))
	}
	if i.TormentLTE != nil {
		predicates = append(predicates, survivor.TormentLTE(*i.TormentLTE))
	}
	if i.Insanity != nil {
		predicates = append(predicates, survivor.InsanityEQ(*i.Insanity))
	}
	if i.InsanityNEQ != nil {
		predicates = append(predicates, survivor.InsanityNEQ(*i.InsanityNEQ))
	}
	if len(i.InsanityIn) > 0 {
		predicates = append(predicates, survivor.InsanityIn(i.InsanityIn...))
	}
	if len(i.InsanityNotIn) > 0 {
		predicates = append(predicates, survivor.InsanityNotIn(i.InsanityNotIn...))
	}
	if i.InsanityGT != nil {
		predicates = append(predicates, survivor.InsanityGT(*i.InsanityGT))
	}
	if i.InsanityGTE != nil {
		predicates = append(predicates, survivor.InsanityGTE(*i.InsanityGTE))
	}
	if i.InsanityLT != nil {
		predicates = append(predicates, survivor.InsanityLT(*i.InsanityLT))
	}
	if i.InsanityLTE != nil {
		predicates = append(predicates, survivor.InsanityLTE(*i.InsanityLTE))
	}
	if i.Lumi != nil {
		predicates = append(predicates, survivor.LumiEQ(*i.Lumi))
	}
	if i.LumiNEQ != nil {
		predicates = append(predicates, survivor.LumiNEQ(*i.LumiNEQ))
	}
	if len(i.LumiIn) > 0 {
		predicates = append(predicates, survivor.LumiIn(i.LumiIn...))
	}
	if len(i.LumiNotIn) > 0 {
		predicates = append(predicates, survivor.LumiNotIn(i.LumiNotIn...))
	}
	if i.LumiGT != nil {
		predicates = append(predicates, survivor.LumiGT(*i.LumiGT))
	}
	if i.LumiGTE != nil {
		predicates = append(predicates, survivor.LumiGTE(*i.LumiGTE))
	}
	if i.LumiLT != nil {
		predicates = append(predicates, survivor.LumiLT(*i.LumiLT))
	}
	if i.LumiLTE != nil {
		predicates = append(predicates, survivor.LumiLTE(*i.LumiLTE))
	}
	if i.Courage != nil {
		predicates = append(predicates, survivor.CourageEQ(*i.Courage))
	}
	if i.CourageNEQ != nil {
		predicates = append(predicates, survivor.CourageNEQ(*i.CourageNEQ))
	}
	if len(i.CourageIn) > 0 {
		predicates = append(predicates, survivor.CourageIn(i.CourageIn...))
	}
	if len(i.CourageNotIn) > 0 {
		predicates = append(predicates, survivor.CourageNotIn(i.CourageNotIn...))
	}
	if i.CourageGT != nil {
		predicates = append(predicates, survivor.CourageGT(*i.CourageGT))
	}
	if i.CourageGTE != nil {
		predicates = append(predicates, survivor.CourageGTE(*i.CourageGTE))
	}
	if i.CourageLT != nil {
		predicates = append(predicates, survivor.CourageLT(*i.CourageLT))
	}
	if i.CourageLTE != nil {
		predicates = append(predicates, survivor.CourageLTE(*i.CourageLTE))
	}
	if i.Understanding != nil {
		predicates = append(predicates, survivor.UnderstandingEQ(*i.Understanding))
	}
	if i.UnderstandingNEQ != nil {
		predicates = append(predicates, survivor.UnderstandingNEQ(*i.UnderstandingNEQ))
	}
	if len(i.UnderstandingIn) > 0 {
		predicates = append(predicates, survivor.UnderstandingIn(i.UnderstandingIn...))
	}
	if len(i.UnderstandingNotIn) > 0 {
		predicates = append(predicates, survivor.UnderstandingNotIn(i.UnderstandingNotIn...))
	}
	if i.UnderstandingGT != nil {
		predicates = append(predicates, survivor.UnderstandingGT(*i.UnderstandingGT))
	}
	if i.UnderstandingGTE != nil {
		predicates = append(predicates, survivor.UnderstandingGTE(*i.UnderstandingGTE))
	}
	if i.UnderstandingLT != nil {
		predicates = append(predicates, survivor.UnderstandingLT(*i.UnderstandingLT))
	}
	if i.UnderstandingLTE != nil {
		predicates = append(predicates, survivor.UnderstandingLTE(*i.UnderstandingLTE))
	}
	if i.SettlementID != nil {
		predicates = append(predicates, survivor.SettlementIDEQ(*i.SettlementID))
	}
	if i.SettlementIDNEQ != nil {
		predicates = append(predicates, survivor.SettlementIDNEQ(*i.SettlementIDNEQ))
	}
	if len(i.SettlementIDIn) > 0 {
		predicates = append(predicates, survivor.SettlementIDIn(i.SettlementIDIn...))
	}
	if len(i.SettlementIDNotIn) > 0 {
		predicates = append(predicates, survivor.SettlementIDNotIn(i.SettlementIDNotIn...))
	}
	if i.SettlementIDIsNil {
		predicates = append(predicates, survivor.SettlementIDIsNil())
	}
	if i.SettlementIDNotNil {
		predicates = append(predicates, survivor.SettlementIDNotNil())
	}

	if i.HasSettlement != nil {
		p := survivor.HasSettlement()
		if !*i.HasSettlement {
			p = survivor.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSettlementWith) > 0 {
		with := make([]predicate.Settlement, 0, len(i.HasSettlementWith))
		for _, w := range i.HasSettlementWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSettlementWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, survivor.HasSettlementWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptySurvivorWhereInput
	case 1:
		return predicates[0], nil
	default:
		return survivor.And(predicates...), nil
	}
}
